# Band Structure Script Documentation

The band structure script performs 8-band k·p calculations for semiconductor nanowires with electrostatic potential coupling. This is the core computational engine of nwkpy, solving the Schrödinger equation for electronic states.

## Overview

**Purpose:** Calculate electronic band structure using 8-band k·p method  
**Input:** Pre-generated mesh files from mesh generation script  
**Output:** Energy bands, charge densities, electrostatic potential, visualization plots  
**Method:** Finite element discretization with MPI parallelization over k-points  

## Quick Usage

```bash
cd scripts/band_structure/
python main.py
```

**For parallel execution:**
```bash
mpirun -np 4 python main.py  # 4 processes for k-point parallelization
```

**Plot-only mode (from existing data):**
```python
# Edit indata.py
plot_only_mode = True
python main.py
```

## File Structure

```
scripts/band_structure/
├── main.py                    # Main execution script
├── indata.py                  # Input parameters (EDIT THIS)
├── mesh.msh                   # Input: mesh geometry (from mesh generation)
├── mesh.dat                   # Input: mesh metadata
├── outdata/                   # Output directory (created automatically)
│   ├── bands.npy             # Energy eigenvalues
│   ├── spinor_dist.npy       # Spinor character distribution
│   ├── envelope_el.npy       # Electron envelope functions
│   ├── envelope_h.npy        # Hole envelope functions
│   ├── total_charge.npy      # Charge balance verification
│   ├── energy_bands.png      # Band structure plot
│   ├── carrier_density.png   # 2D charge density plot
│   ├── potential.png         # Electrostatic potential plot
│   └── band_structure.log    # Execution log
```

## Input Parameters (`indata.py`)

### File Configuration

```python
directory_name = "./outdata"     # Output directory
mesh_name = "./mesh"             # Mesh file base name (no extension)
```

**Mesh requirements:**
- `mesh.msh` and `mesh.dat` must exist in script directory
- Generated by mesh generation script
- Materials must match between mesh and calculation

### Execution Control

```python
plot_only_mode = False           # Set True to only generate plots from existing data
generate_png_graphs = True       # Generate visualization plots after calculation
generate_txt_files = False       # Save results in human-readable text format
MPI_debug = False               # Enable MPI debugging (advanced users)
```

**Execution modes:**
- **Full calculation:** `plot_only_mode = False` - Complete k·p calculation
- **Plot-only:** `plot_only_mode = True` - Generate plots from saved `.npy` files
- **Text output:** `generate_txt_files = True` - Additional human-readable files

### Material Properties

```python
material = ["InAs", "GaSb"]      # Must match mesh generation
valence_band = [0.0, 0.56]       # Valence band offsets [core, shell] in eV
```

**Valence band alignment:**
- Sets energy reference for each material
- Determines heterostructure type (Type I/II/III)
- Critical for correct band lineup

**Common alignments:**
```python
# Type II (staggered) - InAs/GaSb broken-gap
valence_band = [0.0, 0.56]

# Type I (nested) - GaAs/AlGaAs quantum well  
valence_band = [0.0, 0.3]

# Type III (broken-gap) - InAs/GaSb inverted
valence_band = [0.0, 0.74]
```

### Crystal Structure

```python
principal_axis_direction = '111'  # Nanowire growth direction
lattice_constant = 6.0583        # Lattice constant in Angstroms
```

**Growth directions:**
- `'100'` - [100] crystallographic direction
- `'110'` - [110] crystallographic direction  
- `'111'` - [111] crystallographic direction (most common)

**Lattice constant:** Used for k-space scaling and material parameters

### Simulation Conditions

```python
temperature = 4.0                # Temperature in Kelvin
chemical_potential = 0.528       # Fermi level in eV
```

**Temperature effects:**
- Affects band gaps (temperature dependence)
- Controls Fermi-Dirac distribution for charge densities
- Typical values: 4K (liquid He), 77K (liquid N₂), 300K (room temp)

**Chemical potential:**
- Sets Fermi level position
- Determines carrier concentrations
- Should be near band gap for intrinsic materials
- Can be in gap (intrinsic) or in bands (doped)

### Band Structure Parameters

```python
e_search = 0.528                 # Center energy for eigenvalue search (eV)
number_eigenvalues = 20          # Number of subbands to compute
k_range = [0, 0.05]             # k-space range [start, end]
number_k_pts = 4                # Number of k-points
```

**Eigenvalue search:**
- `e_search` should be near chemical potential
- Algorithm searches around this energy
- Include states both above and below Fermi level

**K-space sampling:**
- `k_range` in units of π/√3/lattice_constant
- Only positive values (negative by symmetry)
- More k-points = better resolution, longer calculation

**Example configurations:**
```python
# Quick test
number_eigenvalues = 10
number_k_pts = 4
k_range = [0, 0.03]

# Standard calculation
number_eigenvalues = 20  
number_k_pts = 20
k_range = [0, 0.05]

# High resolution
number_eigenvalues = 40
number_k_pts = 100
k_range = [0, 0.1]
```

### Spurious Solution Suppression

```python
rescale = ['S=0', 'S=0']         # P-parameter rescaling [core, shell]
```

**8-band k·p spurious solutions:**
The 8-band model can produce unphysical high-energy states. The `rescale` parameter controls P-parameter modification to suppress these.

**Options:**
- `'S=0'` - Standard Ep evaluation (Foreman Eq. 6.158)
- `'S=1'` - Modified Ep evaluation (Foreman Eq. 6.159)  
- Numerical value - Fractional Ep reduction (e.g., `0.26` = 26% reduction)

**References:**
- B. A. Foreman, Phys. Rev. B **56**, R12748 (1997)
- S. Birner thesis, TUM (2011)

### Carrier Types

```python
carrier = ["electron", "hole"]   # Dominant carriers [core, shell]
```

**Important for:**
- Broken-gap heterostructures
- Charge density calculations
- Visualization and analysis

### External Fields

```python
electric_field = (0.0, np.pi/2)  # (magnitude in V/μm, angle in radians)
```

**Field specification:**
- Magnitude: Electric field strength in V/μm
- Angle: Direction with respect to x-axis (radians)

**Examples:**
```python
electric_field = (0.0, 0.0)      # No field
electric_field = (0.1, 0.0)      # 0.1 V/μm in x-direction
electric_field = (0.2, np.pi/2)  # 0.2 V/μm in y-direction
electric_field = (0.5, np.pi/4)  # 0.5 V/μm at 45° angle
```

### Numerical Methods

```python
shape_function_kp = ['Hermite', 'LagrangeQuadratic']     # [electrons, holes]
shape_function_poisson = 'LagrangeQuadratic'             # Poisson solver
```

**Shape function selection:**
- **Hermite** - High accuracy, good for electrons, computationally expensive
- **LagrangeQuadratic** - Good balance accuracy/speed, standard choice
- **LagrangeLinear** - Fast but lower accuracy

**Ghost band avoidance:**
Different shape functions can help suppress spurious solutions:
```python
# Conservative (avoid ghost bands)
shape_function_kp = ['Hermite', 'Hermite']

# Balanced (recommended)  
shape_function_kp = ['Hermite', 'LagrangeQuadratic']

# Fast (lower accuracy)
shape_function_kp = ['LagrangeQuadratic', 'LagrangeQuadratic']
```

### Advanced Features

```python
init_pot_name = None             # Path to initial potential file
modified_EFA = True              # Use Modified Envelope Function Approximation
character_threshold = [0.8, 0.95] # State classification thresholds [el, hole]
```

**Initial potential:**
- `None` - Solve Poisson equation from scratch
- Path string - Load pre-computed potential (for restarts)

**Modified EFA:**
- `True` - Better treatment of mixed electron-hole states (recommended)
- `False` - Standard envelope function approximation

**Character thresholds:**
- Classify states as electron-like or hole-like
- States above threshold contribute to charge densities
- Higher values = more selective inclusion

### Boundary Conditions

```python
dirichlet = {
    'ref': None,    # Default: Neumann BC (zero normal E-field)
    1: 0.0,         # Fix potential on boundary 1 to 0.0 eV
}
```

**Boundary condition types:**
- **Dirichlet** - Fixed potential value
- **Neumann** - Fixed normal electric field (usually zero)

**Examples:**
```python
# All Neumann (floating potential)
dirichlet = {'ref': None}

# All Dirichlet at 0V
dirichlet = {'ref': 0.0}

# Mixed: boundary 1 grounded, others floating
dirichlet = {'ref': None, 1: 0.0}

# Multiple contacts
dirichlet = {'ref': None, 1: 0.0, 3: 0.1}  # 0V and 0.1V contacts
```

### Plotting Configuration

```python
plotting_preferencies_bands = {
    'xlim': (0, 0.3),            # k-space range for plot (nm⁻¹)
    'ylim': (515, 560),          # Energy range for plot (meV)
    'cmap_in': 'rainbow',        # Colormap for band character
    'character_to_show': 'H-EL', # Character type to visualize
    'threshold_el': 0.8,         # Electron character threshold
    'threshold_h': 0.95,         # Hole character threshold
    'spines_lw': 4,              # Border line width
    'lw': 5,                     # Band line width
    'fontsize': 20               # Font size
}
```

**Character visualization:**
- `'H-EL'` - Heavy hole vs electron character
- `'LH-EL'` - Light hole vs electron character  
- `'SO-EL'` - Split-off vs electron character

**Plot customization:**
```python
# Publication quality
plotting_preferencies_bands = {
    'xlim': (0, 0.05),
    'ylim': (520, 550), 
    'fontsize': 24,
    'lw': 6,
    'spines_lw': 5
}

# Wide energy range
plotting_preferencies_bands = {
    'xlim': (0, 0.1),
    'ylim': (400, 700),
    'character_to_show': 'H-EL'
}
```

## Script Execution Flow

### 1. Initialization and Validation

```python
# MPI setup
comm = MPI.COMM_WORLD
rank = comm.Get_rank()
size = comm.Get_size()

# Parameter validation
consistency_checks()

# Mesh loading
mesh = Mesh(mesh_file, reg2mat=reg2mat, mat2partic=mat2partic)
```

### 2. K-point Distribution

```python
# Distribute k-points across MPI processes
kmaxlocal = len(kzvals) // size
kin = rank * kmaxlocal
kfin = kin + kmaxlocal
kzslice = np.s_[kin:kfin]
```

**MPI parallelization:**
- Each process handles subset of k-points
- Results collected at end
- Speedup ≈ number of processes (for many k-points)

### 3. Electrostatic Potential

```python
# Solve Poisson equation (rank 0 only)
if rank == 0:
    p = PoissonProblem(mesh, ...)
    p.run()
    Vin = p.epot.V

# Broadcast to all processes
Vin = comm.bcast(Vin, root=0)
```

### 4. Band Structure Calculation

```python
# Each process calculates assigned k-points
bs = BandStructure(
    mesh=mesh,
    kzvals=kzvals[kzslice],  # This process's k-points
    valence_band_edges=valence_band_edges,
    # ... other parameters
)
bs.run()
```

### 5. Data Collection and Synchronization

```python
# Collect results from all processes
comm.Allgather(bs.bands, complete_bands)
comm.Allgather(bs.spinor_distribution, complete_spinor)
# ... collect all arrays
```

### 6. Charge Density Calculation

```python
# Calculate free carrier densities
rho_el = FreeChargeDensity(bs.fs_el)
rho_h = FreeChargeDensity(bs.fs_h)

# Add contributions from all bands/k-points
rho_el.add_charge(bs.psi_el, bs.bands, dk=dk, mu=chemical_potential, ...)
rho_h.add_charge(bs.psi_h, bs.bands, dk=dk, mu=chemical_potential, ...)
```

## Understanding the Output

### Energy Bands (`bands.npy`)

**Format:** NumPy array, shape `(n_k_points, n_eigenvalues)`  
**Units:** eV  
**Content:** Energy eigenvalues for each k-point and subband

```python
# Load and analyze
bands = np.load('outdata/bands.npy')
print(f"Shape: {bands.shape}")
print(f"Energy range: {bands.min():.3f} to {bands.max():.3f} eV")

# Plot dispersion
import matplotlib.pyplot as plt
for i in range(bands.shape[1]):
    plt.plot(kzvals, bands[:, i])
plt.xlabel('k (1/nm)')
plt.ylabel('Energy (eV)')
```

### Spinor Character (`spinor_dist.npy`)

**Format:** NumPy array, shape `(n_k_points, 8, n_eigenvalues)`  
**Content:** 8-component spinor character for each state

**Spinor components:**
1. |S↑⟩ - Spin-up s-like (electron)
2. |X↑⟩ - Spin-up px-like (heavy hole)  
3. |Y↑⟩ - Spin-up py-like (heavy hole)
4. |Z↑⟩ - Spin-up pz-like (light hole)
5. |S↓⟩ - Spin-down s-like (electron)
6. |X↓⟩ - Spin-down px-like (heavy hole)
7. |Y↓⟩ - Spin-down py-like (heavy hole)  
8. |Z↓⟩ - Spin-down pz-like (split-off)

**Analysis:**
```python
spinor = np.load('outdata/spinor_dist.npy')

# Electron character (s-like components)
electron_char = spinor[:, [0, 4], :].sum(axis=1)

# Heavy hole character (px, py components)  
heavy_hole_char = spinor[:, [1, 2, 5, 6], :].sum(axis=1)

# Light hole character (pz component)
light_hole_char = spinor[:, [3, 7], :].sum(axis=1)
```

### Envelope Functions (`envelope_el.npy`, `envelope_h.npy`)

**Format:** Complex NumPy arrays  
**Shape:** `(n_k_points, n_mesh_points, n_spinor_components, n_eigenvalues)`  
**Content:** Spatial wavefunctions for electrons and holes

**Usage:**
```python
psi_el = np.load('outdata/envelope_el.npy')
psi_h = np.load('outdata/envelope_h.npy')

# Probability density at specific k-point and state
k_idx, state_idx = 0, 5
prob_density = np.abs(psi_el[k_idx, :, :, state_idx])**2
```

### Visualization Plots

#### Energy Bands Plot (`energy_bands.png`)

**Features:**
- X-axis: k-vector (nm⁻¹)
- Y-axis: Energy (meV)  
- Colors: Electron (blue) vs hole (red) character
- Horizontal line: Chemical potential

**Interpretation:**
- **Conduction subbands** - Above gap, electron-like (blue)
- **Valence subbands** - Below gap, hole-like (red)
- **Band mixing** - Intermediate colors
- **Quantum confinement** - Discrete energy levels

#### Charge Density Plot (`carrier_density.png`)

**Features:**
- 2D contour map of nanowire cross-section
- Electron density (blue contours)
- Hole density (red contours)
- Material interfaces visible

**Interpretation:**
- **Charge separation** - Different spatial localization
- **Interface effects** - Accumulation at boundaries
- **Quantum confinement** - Spatial distribution

#### Potential Plot (`potential.png`)

**Features:**
- 2D contour map of electrostatic potential
- Built-in fields from charge redistribution
- External field effects

## Common Use Cases

### Example 1: Standard InAs/GaSb Calculation

```python
# Basic broken-gap heterostructure
material = ["InAs", "GaSb"]
valence_band = [0.0, 0.56]
temperature = 4.0
chemical_potential = 0.528
k_range = [0, 0.05]
number_k_pts = 20
number_eigenvalues = 20
```

**Expected results:**
- Electrons localized in InAs core
- Holes localized in GaSb shell  
- Broken-gap band alignment
- Charge separation across interface

### Example 2: Temperature Study

```python
# Compare different temperatures
temperatures = [4.0, 77.0, 300.0]  # K
for T in temperatures:
    temperature = T
    # Run calculation
    # Compare band gaps and charge distributions
```

### Example 3: Electric Field Effects

```python
# Study field-induced band bending
field_strengths = [0.0, 0.1, 0.2, 0.5]  # V/μm
for E in field_strengths:
    electric_field = (E, np.pi/2)
    # Run calculation
    # Analyze field-induced changes
```

### Example 4: Doping Effects (via Chemical Potential)

```python
# Simulate different doping levels
mu_values = [0.50, 0.52, 0.54, 0.56]  # eV
for mu in mu_values:
    chemical_potential = mu
    # Run calculation
    # Compare carrier concentrations
```

### Example 5: High-Resolution Band Structure

```python
# For publication-quality dispersion
number_k_pts = 100
k_range = [0, 0.1]
number_eigenvalues = 40

# Fine energy resolution
plotting_preferencies_bands['ylim'] = (525, 535)  # Zoom to gap region
```

## Troubleshooting

### Common Issues and Solutions

#### Issue 1: "Mesh file not found"

**Error:**
```
FileNotFoundError: Mesh file 'mesh.msh' not found
```

**Solutions:**
1. **Generate mesh first:**
   ```bash
   cd ../mesh_generation
   python main.py
   cp outdata/mesh.* ../band_structure/
   ```

2. **Check mesh path:**
   ```python
   mesh_name = "../mesh_generation/outdata/mesh"
   ```

#### Issue 2: "Material mismatch"

**Error:**
```
ValueError: Material InAs not found in mesh
```

**Solutions:**
```python
# Ensure materials match mesh generation
# mesh_generation/indata.py:
material = ["InAs", "GaSb"]

# band_structure/indata.py:  
material = ["InAs", "GaSb"]  # Must be identical
```

#### Issue 3: Convergence problems

**Error:**
```
Warning: Eigenvalue convergence not achieved
```

**Solutions:**
1. **Adjust search energy:**
   ```python
   e_search = 0.528  # Near chemical potential
   ```

2. **Increase eigenvalue count:**
   ```python
   number_eigenvalues = 30  # More states around Fermi level
   ```

3. **Check mesh quality:**
   - Use finer mesh from mesh generation
   - Verify no degenerate elements

#### Issue 4: Memory errors

**Error:**
```
MemoryError: Unable to allocate array
```

**Solutions:**
1. **Reduce calculation size:**
   ```python
   number_k_pts = 10         # Fewer k-points
   number_eigenvalues = 15   # Fewer states
   ```

2. **Use coarser mesh:**
   - Regenerate mesh with smaller `edges` parameters

3. **MPI parallelization:**
   ```bash
   mpirun -np 4 python main.py  # Distribute memory load
   ```

#### Issue 5: "No states near Fermi level"

**Error:**
```
Warning: Chemical potential outside calculated energy range
```

**Solutions:**
1. **Adjust chemical potential:**
   ```python
   chemical_potential = 0.540  # Move into calculated range
   ```

2. **Expand energy search:**
   ```python
   e_search = 0.540           # Center search better
   number_eigenvalues = 30    # Include more states
   ```

#### Issue 6: Strange band structure

**Symptoms:** Unphysical bands, negative effective masses

**Solutions:**
1. **Check spurious solution suppression:**
   ```python
   rescale = ['S=1', 'S=1']   # Try alternative rescaling
   ```

2. **Try different shape functions:**
   ```python
   shape_function_kp = ['Hermite', 'Hermite']  # Higher accuracy
   ```

3. **Verify material parameters:**
   - Check band gaps are reasonable
   - Verify valence band offsets

## Performance Guidelines

### Calculation Scaling

| K-points | Eigenvalues | Elements | Memory | Time (4 cores) |
|----------|-------------|----------|--------|-----------------|
| 10       | 20          | 2000     | ~1 GB  | ~10 min         |
| 20       | 20          | 2000     | ~2 GB  | ~20 min         |
| 50       | 30          | 5000     | ~8 GB  | ~2 hours        |
| 100      | 40          | 10000    | ~32 GB | ~8 hours        |

### MPI Recommendations

```bash
# Optimal: n_processes = n_k_points (or divisor)
mpirun -np 20 python main.py  # For 20 k-points

# Good: n_processes < n_k_points  
mpirun -np 4 python main.py   # For any k-point count

# Inefficient: n_processes > n_k_points
mpirun -np 40 python main.py  # For 20 k-points (wasteful)
```

### Memory Optimization

```python
# For large calculations, reduce precision
generate_txt_files = False     # Save space
MPI_debug = False             # Reduce debug overhead

# Monitor memory usage
import psutil
print(f"Memory: {psutil.virtual_memory().percent}%")
```

## Integration with Other Scripts

### After Mesh Generation

```bash
# Workflow
cd mesh_generation/
python main.py               # Generate mesh

cd ../band_structure/
cp ../mesh_generation/outdata/mesh.* ./  # Copy mesh files
python main.py               # Calculate bands
```

### Before Self-Consistent

```bash
# Use band structure results as starting point
cd ../self_consistent/
cp ../band_structure/outdata/epot_conv.npy ./initial_potential.npy

# In self_consistent/indata.py:
init_pot_name = "initial_potential.npy"
```

### Parameter Consistency

Ensure parameters match across all scripts:

```python
# All scripts should have identical:
material = ["InAs", "GaSb"]
carrier = ["electron", "hole"]  
valence_band = [0.0, 0.56]
temperature = 4.0
```

## Advanced Analysis

### Custom Band Analysis

```python
# Load results for analysis
bands = np.load('outdata/bands.npy')
kzvals = np.load('outdata/kzvals.npy')
spinor = np.load('outdata/spinor_dist.npy')

# Find band gap
conduction_min = bands[bands > chemical_potential].min()
valence_max = bands[bands < chemical_potential].max()
band_gap = conduction_min - valence_max

print(f"Band gap: {band_gap*1000:.1f} meV")

# Effective masses (numerical derivative)
def effective_mass(E, k):
    """Calculate effective mass from E(k)"""
    dE_dk = np.gradient(E, k)
    d2E_dk2 = np.gradient(dE_dk, k)
    m_eff = hbar**2 / d2E_dk2  # In appropriate units
    return m_eff
```

### Export for External Analysis

```python
# Export to formats readable by other tools
import pandas as pd

# Create DataFrame for band structure
df = pd.DataFrame()
for i, k in enumerate(kzvals):
    for j, E in enumerate(bands[i, :]):
        df = df.append({
            'k': k,
            'band': j, 
            'energy': E,
            'electron_char': spinor[i, [0,4], j].sum()
        }, ignore_index=True)

df.to_csv('band_structure.csv', index=False)
```

## Related Documentation

- **[Mesh Generation](mesh_generation.md)** - Required prerequisite
- **[Self-Consistent Calculations](self_consistent.md)** - Advanced coupling
- **[Physics Background](../PHYSICS_BACKGROUND.md)** - k·p theory details
- **[Installation Guide](../INSTALLATION.md)** - MPI setup for parallelization

## Next Steps

✅ **Band structure calculated successfully?**

🎯 **Continue with:**
1. **[Self-Consistent Calculations](self_consistent.md)** - Include charge redistribution
2. **[Parameter Studies](../TUTORIALS/02_band_structure.md)** - Systematic parameter variation
3. **[Advanced Analysis](../TUTORIALS/04_advanced_topics.md)** - Custom post-processing

📊 **Analysis suggestions:**
- Compare with experimental data
- Study temperature dependence  
- Analyze effective masses
- Calculate optical transition matrix elements